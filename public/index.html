<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat App</title>
  <link rel="stylesheet" href="/public/styles.css">

</head>

<body>
  <header>
    <div class="header-left">
      <h1>üí¨ Connecto</h1>
      <div class="online-indicator"></div>
    </div>
    <div class="header-right">
      <span id="userName" class="user-name" title="You are signed in as"></span>
      <a href="/logout" id="logoutLink" class="logout-btn">Logout</a>
    </div>
  </header>

  <div id="messages">
    <div class="empty-state" id="emptyState">
      <div class="empty-state-icon">üí¨</div>
      <h3>Welcome to Connecto!</h3>
      <p>Start a conversation by sending your first message below.</p>
    </div>
  </div>

  <div id="form">
    <button class="emoji-toggle" id="emojiToggle" title="Add emoji">üòÄ</button>
    <textarea id="message" placeholder="Type your message..." autocomplete="off" rows="1"></textarea>
    <button id="sendbtn" title="Send message">‚û§</button>
  </div>
  <div class="typing-indicator" id="typingIndicator">Someone is typing...</div>

  <!-- Emoji Picker -->
  <div class="emoji-picker" id="emojiPicker">
    <div class="emoji-categories">
      <button class="emoji-category-btn active" data-category="smileys">üòÄ</button>
      <button class="emoji-category-btn" data-category="people">üëã</button>
      <button class="emoji-category-btn" data-category="nature">üåü</button>
      <button class="emoji-category-btn" data-category="food">üçï</button>
      <button class="emoji-category-btn" data-category="activities">‚öΩ</button>
      <button class="emoji-category-btn" data-category="travel">‚úàÔ∏è</button>
      <button class="emoji-category-btn" data-category="objects">üí°</button>
      <button class="emoji-category-btn" data-category="symbols">‚ù§Ô∏è</button>
    </div>
    <div class="emoji-grid" id="emojiGrid">
      <!-- Emojis will be populated by JavaScript -->
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // Initialize with user data from server
    const currentUser = window.userData || { userName: 'Anonymous', userId: null };
    console.log('Current user data:', currentUser);
    
    // Initialize socket with query parameters for user data
    const socket = io({
        reconnection: true,
        reconnectionAttempts: 5,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        timeout: 20000,
        query: {
            userId: currentUser.userId || null,
            userName: currentUser.userName || 'Anonymous'
        },
        auth: {
            token: currentUser.userId ? 'user-' + currentUser.userId : 'anonymous'
        }
    });
    
    const sendbtn = document.getElementById("sendbtn");
    const messageInput = document.getElementById("message");
    const allMessages = document.getElementById("messages");

    let lastSentMessage = "";
    let isConnected = false;
    const emptyState = document.getElementById('emptyState');
    const emojiToggle = document.getElementById('emojiToggle');
    const emojiPicker = document.getElementById('emojiPicker');
    const emojiGrid = document.getElementById('emojiGrid');
    const categoryBtns = document.querySelectorAll('.emoji-category-btn');
    
    // Handle socket connection
    socket.on('connect', () => {
        console.log('Socket connected with ID:', socket.id);
        isConnected = true;
        
        // Join chat with user data
        if (currentUser.userId) {
            console.log('Joining chat as user:', currentUser.userName);
            socket.emit('join-chat', {
                userId: currentUser.userId,
                userName: currentUser.userName
            });
        } else {
            console.warn('No user ID available, joining as anonymous');
            socket.emit('join-chat', {
                userId: null,
                userName: 'Anonymous'
            });
        }
    });
    
    // Handle connection errors
    socket.on('connect_error', (error) => {
        console.error('Socket connection error:', error);
        isConnected = false;
    });
    
    // Handle successful join
    socket.on('join-acknowledged', (data) => {
        console.log('Join acknowledged:', data);
        if (data.userName) {
            currentUser.userName = data.userName;
        }
    });
    
    // Handle join errors
    socket.on('join-error', (error) => {
        console.error('Error joining chat:', error);
        // Show error to user
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = 'Error connecting to chat. Please refresh the page.';
        document.body.prepend(errorDiv);
        
        // Remove error after 5 seconds
        setTimeout(() => {
            errorDiv.remove();
        }, 5000);
    });

    // Emoji data organized by categories
    const emojiCategories = {
      smileys: ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'ü§£', 'üòÇ', 'üôÇ', 'üôÉ', 'üòâ', 'üòä', 'üòá', 'ü•∞', 'üòç', 'ü§©', 'üòò', 'üòó', 'üòö', 'üòô', 'üòã', 'üòõ', 'üòú', 'ü§™', 'üòù', 'ü§ë', 'ü§ó', 'ü§≠', 'ü§´', 'ü§î', 'ü§ê', 'ü§®', 'üòê', 'üòë', 'üò∂', 'üòè', 'üòí', 'üôÑ', 'üò¨', 'ü§•', 'üòî', 'üò™', 'ü§§', 'üò¥', 'üò∑', 'ü§í', 'ü§ï', 'ü§¢', 'ü§Æ', 'ü§ß', 'ü•µ', 'ü•∂', 'ü•¥', 'üòµ', 'ü§Ø', 'ü§†', 'ü•≥', 'üòé', 'ü§ì', 'üßê'],
      people: ['üëã', 'ü§ö', 'üñêÔ∏è', '‚úã', 'üññ', 'üëå', 'ü§è', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô', 'üëà', 'üëâ', 'üëÜ', 'üñï', 'üëá', '‚òùÔ∏è', 'üëç', 'üëé', 'üëä', '‚úä', 'ü§õ', 'ü§ú', 'üëè', 'üôå', 'üëê', 'ü§≤', 'ü§ù', 'üôè', '‚úçÔ∏è', 'üíÖ', 'ü§≥', 'üí™', 'ü¶æ', 'ü¶ø', 'ü¶µ', 'ü¶∂', 'üëÇ', 'ü¶ª', 'üëÉ', 'üß†', 'ü¶∑', 'ü¶¥', 'üëÄ', 'üëÅÔ∏è', 'üëÖ', 'üëÑ', 'üíã', 'ü©∏'],
      nature: ['üåü', '‚≠ê', 'üå†', '‚òÄÔ∏è', 'üåû', 'üåù', 'üåõ', 'üåú', 'üåö', 'üåï', 'üåñ', 'üåó', 'üåò', 'üåë', 'üåí', 'üåì', 'üåî', 'üåô', 'üåé', 'üåç', 'üåè', 'üí´', '‚ö°', '‚òÑÔ∏è', 'üí•', 'üî•', 'üå™Ô∏è', 'üåà', '‚òÇÔ∏è', '‚òî', '‚õàÔ∏è', 'üå§Ô∏è', '‚õÖ', 'üå¶Ô∏è', 'üåßÔ∏è', '‚õÜ', '‚ùÑÔ∏è', '‚òÉÔ∏è', '‚õÑ', 'üå®Ô∏è', 'üí®', 'üíß', 'üí¶', 'üåä'],
      food: ['üçï', 'üçî', 'üçü', 'üå≠', 'ü•™', 'üåÆ', 'üåØ', 'ü•ô', 'üßÜ', 'ü•ö', 'üç≥', 'ü•ò', 'üç≤', 'ü•£', 'ü•ó', 'üçø', 'üßà', 'üßÇ', 'ü•®', 'ü•ñ', 'üçû', 'ü•ê', 'ü•Ø', 'üßá', 'ü•û', 'üç∞', 'üéÇ', 'üßÅ', 'ü•ß', 'üç´', 'üç¨', 'üç≠', 'üçÆ', 'üçØ', 'üçº', 'ü•õ', '‚òï', 'üçµ', 'üßÉ', 'ü•§', 'üç∂', 'üç∫', 'üçª', 'ü•Ç', 'üç∑', 'ü•É', 'üç∏', 'üçπ', 'üßâ', 'üçæ'],
      activities: ['‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'ü•é', 'üéæ', 'üèê', 'üèâ', 'ü•è', 'üé±', 'ü™Ä', 'üèì', 'üè∏', 'üèí', 'üèë', 'ü•ç', 'üèè', 'ü™É', 'ü•Ö', '‚õ≥', 'ü™Å', 'üèπ', 'üé£', 'ü§ø', 'ü•ä', 'ü•ã', 'üéΩ', 'üõπ', 'üõ∑', '‚õ∏Ô∏è', 'ü•å', 'üéø', '‚õ∑Ô∏è', 'üèÇ', 'ü™Ç', 'üèãÔ∏è', 'ü§º', 'ü§∏', '‚õπÔ∏è', 'ü§∫', 'ü§æ', 'üèåÔ∏è', 'üèá', 'üßò', 'üèÑ', 'üèä', 'ü§Ω', 'üö£', 'üßó', 'üöµ', 'üö¥', 'üèÜ', 'ü•á', 'ü•à', 'ü•â', 'üèÖ', 'üéñÔ∏è', 'üèµÔ∏è', 'üéóÔ∏è'],
      travel: ['‚úàÔ∏è', 'üõ´', 'üõ¨', 'ü™Ç', 'üí∫', 'üöÅ', 'üöü', 'üö†', 'üö°', 'üõ∞Ô∏è', 'üöÄ', 'üõ∏', 'üöÇ', 'üöÉ', 'üöÑ', 'üöÖ', 'üöÜ', 'üöá', 'üöà', 'üöâ', 'üöä', 'üöù', 'üöû', 'üöã', 'üöå', 'üöç', 'üöé', 'üöê', 'üöë', 'üöí', 'üöì', 'üöî', 'üöï', 'üöñ', 'üöó', 'üöò', 'üöô', 'üõª', 'üöö', 'üöõ', 'üöú', 'üèéÔ∏è', 'üèçÔ∏è', 'üõµ', 'ü¶Ω', 'ü¶º', 'üõ¥', 'üö≤', 'üõ∫', 'üö®', 'üö•', 'üö¶', 'üõë', 'üöß'],
      objects: ['üí°', 'üî¶', 'üïØÔ∏è', 'ü™î', 'üßØ', 'üõ¢Ô∏è', 'üí∏', 'üíµ', 'üí¥', 'üí∂', 'üí∑', 'üí∞', 'üí≥', 'üíé', '‚öñÔ∏è', 'üß∞', 'üîß', 'üî®', '‚öíÔ∏è', 'üõ†Ô∏è', '‚õèÔ∏è', 'ü™ì', 'ü™ö', 'üî©', '‚öôÔ∏è', 'üß±', '‚õìÔ∏è', 'üß≤', 'üî´', 'üí£', 'üß®', 'ü™É', 'üèπ', 'üõ°Ô∏è', 'ü™ö', 'üî™', '‚öîÔ∏è', 'üì±', 'üìû', '‚òéÔ∏è', 'üìü', 'üì†', 'üîã', 'ü™´', 'üîå', 'üíª', 'üñ•Ô∏è', 'üñ®Ô∏è', '‚å®Ô∏è', 'üñ±Ô∏è', 'üñ≤Ô∏è', 'üíΩ', 'üíæ', 'üíø', 'üìÄ', 'üßÆ', 'üé•', 'üì∂', 'üàÅ', 'üî£', '‚ÑπÔ∏è', 'üî§', 'üî°', 'üî†', 'üÜñ', 'üÜó', 'üÜô', 'üÜí', 'üÜï', 'üÜì', '0Ô∏è‚É£', '1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£', '7Ô∏è‚É£', '8Ô∏è‚É£', '9Ô∏è‚É£', 'üîü'],
      symbols: ['‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç', 'ü§é', 'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ', 'üíò', 'üíù', 'üíü', '‚òÆÔ∏è', '‚úùÔ∏è', '‚ò™Ô∏è', 'üïâÔ∏è', '‚ò∏Ô∏è', '‚ú°Ô∏è', 'üîØ', 'üïé', '‚òØÔ∏è', '‚ò¶Ô∏è', 'üõê', '‚õé', '‚ôà', '‚ôâ', '‚ôä', '‚ôã', '‚ôå', '‚ôç', '‚ôé', '‚ôè', '‚ôê', '‚ôë', '‚ôí', '‚ôì', 'üÜî', '‚öõÔ∏è', 'üâë', '‚ò¢Ô∏è', '‚ò£Ô∏è', 'üì¥', 'üì≥', 'üà∂', 'üàö', 'üà∏', 'üà∫', 'üà∑Ô∏è', '‚ú¥Ô∏è', 'üÜö', 'üíÆ', 'üâê', '„äôÔ∏è', '„äóÔ∏è', 'üà¥', 'üàµ', 'üàπ', 'üà≤', 'üÖ∞Ô∏è', 'üÖ±Ô∏è', 'üÜé', 'üÜë', 'üÖæÔ∏è', 'üÜò', '‚ùå', '‚≠ï', 'üõë', '‚õî', 'üìõ', 'üö´', 'üíØ', 'üí¢', '‚ô®Ô∏è', 'üö∑', 'üöØ', 'üö≥', 'üö±', 'üîû', 'üìµ', 'üö≠', '‚ùó', '‚ùï', '‚ùì', '‚ùî', '‚ÄºÔ∏è', '‚ÅâÔ∏è', 'üîÖ', 'üîÜ', '„ÄΩÔ∏è', '‚ö†Ô∏è', 'üö∏', 'üî±', '‚öúÔ∏è', 'üî∞', '‚ôªÔ∏è', '‚úÖ', 'üàØ', 'üíπ', '‚ùáÔ∏è', '‚ú≥Ô∏è', '‚ùé', 'üåê', 'üí†', '‚ìÇÔ∏è', 'üåÄ', 'üí§', 'üèß', 'üöæ', '‚ôø', 'üÖøÔ∏è', 'üà≥', 'üàÇÔ∏è', 'üõÇ', 'üõÉ', 'üõÑ', 'üõÖ', 'üöπ', 'üö∫', 'üöº', 'üöª', 'üöÆ', 'üé¶', 'üì∂', 'üàÅ', 'üî£', '‚ÑπÔ∏è', 'üî§', 'üî°', 'üî†', 'üÜñ', 'üÜó', 'üÜô', 'üÜí', 'üÜï', 'üÜì', '0Ô∏è‚É£', '1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£', '7Ô∏è‚É£', '8Ô∏è‚É£', '9Ô∏è‚É£', 'üîü']
    };

    // Auto-resize textarea
    messageInput.addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 120) + 'px';
    });

    // Hide empty state when messages exist
    function hideEmptyState() {
      if (emptyState) {
        emptyState.style.display = 'none';
      }
    }

    // Initialize emoji picker
    function initEmojiPicker() {
      showEmojiCategory('smileys');
      
      // Toggle emoji picker
      emojiToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        emojiPicker.classList.toggle('show');
        emojiToggle.classList.toggle('active');
      });

      // Category switching
      categoryBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          categoryBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          showEmojiCategory(btn.dataset.category);
        });
      });

      // Close picker when clicking outside
      document.addEventListener('click', (e) => {
        if (!emojiPicker.contains(e.target) && !emojiToggle.contains(e.target)) {
          emojiPicker.classList.remove('show');
          emojiToggle.classList.remove('active');
        }
      });
    }

    function showEmojiCategory(category) {
      const emojis = emojiCategories[category] || [];
      emojiGrid.innerHTML = '';
      
      emojis.forEach(emoji => {
        const btn = document.createElement('button');
        btn.className = 'emoji-btn';
        btn.textContent = emoji;
        btn.addEventListener('click', () => insertEmoji(emoji));
        emojiGrid.appendChild(btn);
      });
    }

    function insertEmoji(emoji) {
      const cursorPos = messageInput.selectionStart;
      const textBefore = messageInput.value.substring(0, cursorPos);
      const textAfter = messageInput.value.substring(messageInput.selectionEnd);
      
      messageInput.value = textBefore + emoji + textAfter;
      messageInput.focus();
      messageInput.setSelectionRange(cursorPos + emoji.length, cursorPos + emoji.length);
      
      // Auto-resize textarea
      messageInput.style.height = 'auto';
      messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
      
      // Close picker
      emojiPicker.classList.remove('show');
      emojiToggle.classList.remove('active');
    }

    // Initialize emoji picker
    initEmojiPicker();

    // User data is handled during socket connection

    // Handle incoming messages
    socket.on("message", (msgData) => {
      hideEmptyState();
      
      // Check if message is valid
      if (!msgData || typeof msgData !== 'object') {
        console.error('Invalid message format:', msgData);
        return;
      }
      
      // Check if this is our own message that was just sent
      if (msgData.text === lastSentMessage) {
        // Find and update the pending message with the server's timestamp
        const pendingMessage = document.querySelector(`[data-temp-id="${msgData.tempId}"]`);
        if (pendingMessage) {
          const metaEl = pendingMessage.querySelector('.meta');
          if (metaEl) {
            metaEl.textContent = msgData.time || new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          }
          // Remove the temp ID since we've received the server's copy
          pendingMessage.removeAttribute('data-temp-id');
        }
        lastSentMessage = "";
        return;
      }
      
      // Extract message text - handle both direct string and object with text property
      const messageText = typeof msgData === 'string' ? msgData : 
                         (msgData.text || JSON.stringify(msgData));
      
      // Check if this is our own message (from another tab/device)
      const isCurrentUser = currentUser.userId && msgData.userId === currentUser.userId;
      
      // Create message element
      const div = document.createElement("div");
      div.classList.add("message", isCurrentUser ? "self" : "other");
      
      // Format display name
      const displayName = isCurrentUser ? 'You' : (msgData.userName || 'Anonymous');
      
      // Format time - use provided time or current time
      const displayTime = msgData.time || new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      // Create message HTML
      div.innerHTML = `
        <div class="message-content">
          <div class="message-header">
            <strong>${escapeHtml(displayName)}</strong>
          </div>
          <div class="message-body">
            <span class="message-text">${escapeHtml(messageText)}</span>
            <span class="meta">${displayTime}</span>
          </div>
        </div>
      `;
      
      allMessages.appendChild(div);
      smoothScrollToBottom();
    });

    // Send message
    sendbtn.addEventListener("click", sendMessage);
    messageInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // Utility functions
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function smoothScrollToBottom() {
      allMessages.scrollTo({
        top: allMessages.scrollHeight,
        behavior: 'smooth'
      });
    }

    // Send message function
    function sendMessage() {
      const message = messageInput.value.trim();
      if (!message) return;

      // Only allow sending if we have a valid user ID
      if (!currentUser.userId) {
        alert('Please sign in to send messages');
        return;
      }
      
      // Show sending state
      const tempId = 'msg-' + Date.now();
      const tempDiv = document.createElement("div");
      tempDiv.className = "message self";
      tempDiv.setAttribute('data-temp-id', tempId);
      tempDiv.innerHTML = `
        <div class="message-content">
          <div class="message-header">
            <strong>You</strong>
          </div>
          <div class="message-body">
            <span class="message-text">${escapeHtml(message)}</span>
            <span class="meta">Sending...</span>
          </div>
        </div>
      `;
      allMessages.appendChild(tempDiv);
      smoothScrollToBottom();
      
      // Store the last sent message to handle duplicates
      lastSentMessage = message;
      
      // Clear input
      messageInput.value = '';
      messageInput.style.height = 'auto';
      
      // Send message to server with user data
      if (isConnected) {
        const messageData = {
          text: message,
          userId: currentUser.userId,
          userName: currentUser.userName,
          tempId: tempId  // Include tempId to track this message
        };
        
        socket.emit('user-message', messageData, (response) => {
          if (!response || !response.success) {
            console.error('Failed to send message:', response?.error || 'Unknown error');
            const errorEl = document.querySelector(`[data-temp-id="${tempId}"] .meta`);
            if (errorEl) {
              errorEl.textContent = 'Failed to send';
              errorEl.style.color = '#ff6b6b';
            }
            return;
          }
          
          // Message was sent successfully
          const messageEl = document.querySelector(`[data-temp-id="${tempId}"]`);
          if (messageEl) {
            const metaEl = messageEl.querySelector('.meta');
            if (metaEl && response.messageData?.time) {
              metaEl.textContent = response.messageData.time;
            }
            // Remove the temp ID since we've updated the message
            messageEl.removeAttribute('data-temp-id');
          }
          
          // Clear the last sent message
          if (message === lastSentMessage) {
            lastSentMessage = "";
          }
        });
      }
      
      // Set focus back to the input
      messageInput.focus();
    }

    // Populate username in header
    const userNameEl = document.getElementById('userName');
    if (userNameEl) userNameEl.textContent = currentUser.userName || 'User';

    // Add confirmation dialog for logout
    const logoutLink = document.getElementById('logoutLink');
    if (logoutLink) {
      logoutLink.addEventListener('click', (e) => {
        const name = currentUser.userName || 'this account';
        if (!confirm(`Are you sure you want to log out of ${name}?`)) {
          e.preventDefault();
        }
      });
    }
  </script>

</body>

</html>